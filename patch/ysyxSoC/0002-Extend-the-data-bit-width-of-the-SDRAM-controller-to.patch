From 81cec861d01a3125784e4230481288d4e0a3bdce Mon Sep 17 00:00:00 2001
From: CmdBlock <CmdBlockZQG@outlook.com>
Date: Mon, 22 Apr 2024 21:27:08 +0800
Subject: [PATCH 02/13] Extend the data bit width of the SDRAM controller to 32
 bits

---
 perip/sdram/core_sdram_axi4/sdram_axi.v      |   6 +-
 perip/sdram/core_sdram_axi4/sdram_axi_core.v |  77 ++-------
 perip/sdram/sdram.v                          | 170 ++-----------------
 perip/sdram/sdram_comp.v                     | 170 +++++++++++++++++++
 perip/sdram/sdram_top_apb.v                  |   8 +-
 perip/sdram/sdram_top_axi.v                  |   8 +-
 src/device/SDRAM.scala                       |   4 +-
 7 files changed, 213 insertions(+), 230 deletions(-)
 create mode 100644 perip/sdram/sdram_comp.v

diff --git a/perip/sdram/core_sdram_axi4/sdram_axi.v b/perip/sdram/core_sdram_axi4/sdram_axi.v
index 64641f58b..e743eb164 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi.v
@@ -53,7 +53,7 @@ module sdram_axi
     ,input  [  7:0]  inport_arlen_i
     ,input  [  1:0]  inport_arburst_i
     ,input           inport_rready_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_awready_o
@@ -73,10 +73,10 @@ module sdram_axi
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
+    ,output [  3:0]  sdram_dqm_o
     ,output [ 12:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
 );
 
diff --git a/perip/sdram/core_sdram_axi4/sdram_axi_core.v b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
index cedbf77b2..920b3fc44 100644
--- a/perip/sdram/core_sdram_axi4/sdram_axi_core.v
+++ b/perip/sdram/core_sdram_axi4/sdram_axi_core.v
@@ -42,7 +42,7 @@ module sdram_axi_core
     ,input  [  7:0]  inport_len_i
     ,input  [ 31:0]  inport_addr_i
     ,input  [ 31:0]  inport_write_data_i
-    ,input  [ 15:0]  sdram_data_input_i
+    ,input  [ 31:0]  sdram_data_input_i
 
     // Outputs
     ,output          inport_accept_o
@@ -55,10 +55,10 @@ module sdram_axi_core
     ,output          sdram_ras_o
     ,output          sdram_cas_o
     ,output          sdram_we_o
-    ,output [  1:0]  sdram_dqm_o
+    ,output [  3:0]  sdram_dqm_o
     ,output [ 12:0]  sdram_addr_o
     ,output [  1:0]  sdram_ba_o
-    ,output [ 15:0]  sdram_data_output_o
+    ,output [ 31:0]  sdram_data_output_o
     ,output          sdram_data_out_en_o
 );
 
@@ -76,7 +76,7 @@ parameter SDRAM_READ_LATENCY     = 2;
 // Defines / Local params
 //-----------------------------------------------------------------
 localparam SDRAM_BANK_W          = 2;
-localparam SDRAM_DQM_W           = 2;
+localparam SDRAM_DQM_W           = 4;
 localparam SDRAM_BANKS           = 2 ** SDRAM_BANK_W;
 localparam SDRAM_ROW_W           = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W;
 localparam SDRAM_REFRESH_CNT     = 2 ** SDRAM_ROW_W;
@@ -94,7 +94,7 @@ localparam CMD_REFRESH       = 4'b0001;
 localparam CMD_LOAD_MODE     = 4'b0000;
 
 // Mode: Burst Length = 4 bytes, CAS=2
-localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b001};
+localparam MODE_REG          = {3'b000,1'b0,2'b00,3'b010,1'b0,3'b000};
 
 // SM states
 localparam STATE_W           = 4;
@@ -105,14 +105,13 @@ localparam STATE_ACTIVATE    = 4'd3;
 localparam STATE_READ        = 4'd4;
 localparam STATE_READ_WAIT   = 4'd5;
 localparam STATE_WRITE0      = 4'd6;
-localparam STATE_WRITE1      = 4'd7;
 localparam STATE_PRECHARGE   = 4'd8;
 localparam STATE_REFRESH     = 4'd9;
 
 localparam AUTO_PRECHARGE    = 10;
 localparam ALL_BANKS         = 10;
 
-localparam SDRAM_DATA_W      = 16;
+localparam SDRAM_DATA_W      = 32;
 
 localparam CYCLE_TIME_NS     = 1000 / SDRAM_MHZ;
 
@@ -159,10 +158,6 @@ reg [SDRAM_DQM_W-1:0]  dqm_q;
 reg                    cke_q;
 reg [SDRAM_BANK_W-1:0] bank_q;
 
-// Buffer half word during read and write commands
-reg [SDRAM_DATA_W-1:0] data_buffer_q;
-reg [SDRAM_DQM_W-1:0]  dqm_buffer_q;
-
 wire [SDRAM_DATA_W-1:0] sdram_data_in_w;
 
 reg                    refresh_q;
@@ -177,7 +172,7 @@ reg  [STATE_W-1:0]     target_state_q;
 reg  [STATE_W-1:0]     delay_state_q;
 
 // Address bits
-wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W-SDRAM_COL_W){1'b0}}, ram_addr_w[SDRAM_COL_W:2], 1'b0};
+wire [SDRAM_ROW_W-1:0]  addr_col_w  = {{(SDRAM_ROW_W-SDRAM_COL_W+1){1'b0}}, ram_addr_w[SDRAM_COL_W:2]};
 wire [SDRAM_ROW_W-1:0]  addr_row_w  = ram_addr_w[SDRAM_ADDR_W:SDRAM_COL_W+2+1];
 wire [SDRAM_BANK_W-1:0] addr_bank_w = ram_addr_w[SDRAM_COL_W+2:SDRAM_COL_W+2-1];
 
@@ -283,13 +278,6 @@ begin
     // STATE_WRITE0
     //-----------------------------------------
     STATE_WRITE0 :
-    begin
-        next_state_r = STATE_WRITE1;
-    end
-    //-----------------------------------------
-    // STATE_WRITE1
-    //-----------------------------------------
-    STATE_WRITE1 :
     begin
         next_state_r = STATE_IDLE;
 
@@ -483,13 +471,12 @@ always @ (posedge clk_i or posedge rst_i)
 if (rst_i)
 begin
     command_q       <= CMD_NOP;
-    data_q          <= 16'b0;
+    data_q          <= 32'b0;
     addr_q          <= {SDRAM_ROW_W{1'b0}};
     bank_q          <= {SDRAM_BANK_W{1'b0}};
     cke_q           <= 1'b0;
     dqm_q           <= {SDRAM_DQM_W{1'b0}};
     data_rd_en_q    <= 1'b1;
-    dqm_buffer_q    <= {SDRAM_DQM_W{1'b0}};
 
     for (idx=0;idx<SDRAM_BANKS;idx=idx+1)
         active_row_q[idx] <= {SDRAM_ROW_W{1'b0}};
@@ -616,63 +603,34 @@ begin
         command_q       <= CMD_WRITE;
         addr_q          <= addr_col_w;
         bank_q          <= addr_bank_w;
-        data_q          <= ram_write_data_w[15:0];
+        data_q          <= ram_write_data_w;
 
         // Disable auto precharge (auto close of row)
         addr_q[AUTO_PRECHARGE]  <= 1'b0;
 
         // Write mask
-        dqm_q           <= ~ram_wr_w[1:0];
-        dqm_buffer_q    <= ~ram_wr_w[3:2];
+        dqm_q           <= ~ram_wr_w;
 
         data_rd_en_q    <= 1'b0;
     end
-    //-----------------------------------------
-    // STATE_WRITE1
-    //-----------------------------------------
-    STATE_WRITE1 :
-    begin
-        // Burst continuation
-        command_q   <= CMD_NOP;
-
-        data_q      <= data_buffer_q;
-
-        // Disable auto precharge (auto close of row)
-        addr_q[AUTO_PRECHARGE]  <= 1'b0;
-
-        // Write mask
-        dqm_q       <= dqm_buffer_q;
-    end
     endcase
 end
 
 //-----------------------------------------------------------------
 // Record read events
 //-----------------------------------------------------------------
-reg [SDRAM_READ_LATENCY+1:0]  rd_q;
+reg [SDRAM_READ_LATENCY:0]  rd_q;
 
 always @ (posedge clk_i or posedge rst_i)
 if (rst_i)
-    rd_q    <= {(SDRAM_READ_LATENCY+2){1'b0}};
+    rd_q    <= {(SDRAM_READ_LATENCY+1){1'b0}};
 else
-    rd_q    <= {rd_q[SDRAM_READ_LATENCY:0], (state_q == STATE_READ)};
+    rd_q    <= {rd_q[SDRAM_READ_LATENCY - 1:0], (state_q == STATE_READ)};
 
 //-----------------------------------------------------------------
-// Data Buffer
-//-----------------------------------------------------------------
-
-// Buffer upper 16-bits of write data so write command can be accepted
-// in WRITE0. Also buffer lower 16-bits of read data.
-always @ (posedge clk_i or posedge rst_i)
-if (rst_i)
-    data_buffer_q <= 16'b0;
-else if (state_q == STATE_WRITE0)
-    data_buffer_q <= ram_write_data_w[31:16];
-else if (rd_q[SDRAM_READ_LATENCY+1])
-    data_buffer_q <= sample_data_q;
-
 // Read data output
-assign ram_read_data_w = {sample_data_q, data_buffer_q};
+//-----------------------------------------------------------------
+assign ram_read_data_w = sample_data_q;
 
 //-----------------------------------------------------------------
 // ACK
@@ -684,9 +642,9 @@ if (rst_i)
     ack_q   <= 1'b0;
 else
 begin
-    if (state_q == STATE_WRITE1)
+    if (state_q == STATE_WRITE0)
         ack_q <= 1'b1;
-    else if (rd_q[SDRAM_READ_LATENCY+1])
+    else if (rd_q[SDRAM_READ_LATENCY])
         ack_q <= 1'b1;
     else
         ack_q <= 1'b0;
@@ -730,7 +688,6 @@ begin
     STATE_READ        : dbg_state = "READ";
     STATE_READ_WAIT   : dbg_state = "READ_WAIT";
     STATE_WRITE0      : dbg_state = "WRITE0";
-    STATE_WRITE1      : dbg_state = "WRITE1";
     STATE_PRECHARGE   : dbg_state = "PRECHARGE";
     STATE_REFRESH     : dbg_state = "REFRESH";
     default           : dbg_state = "UNKNOWN";
diff --git a/perip/sdram/sdram.v b/perip/sdram/sdram.v
index 75cb87ad4..637fd090d 100644
--- a/perip/sdram/sdram.v
+++ b/perip/sdram/sdram.v
@@ -7,164 +7,20 @@ module sdram(
   input        we,
   input [12:0] a,
   input [ 1:0] ba,
-  input [ 1:0] dqm,
-  inout [15:0] dq
+  input [ 3:0] dqm,
+  inout [31:0] dq
 );
 
-  reg [15:0] mem [4][8192][512];
-
-  // -------------------- I/O --------------------
-  reg [1:0] dqm_fifo [3];
-  always @(posedge clk) if (cke) begin
-    dqm_fifo[1] <= dqm;
-    dqm_fifo[0] <= dqm_fifo[1];
-  end
-  reg dq_out_en;
-  reg [15:0] dq_out;
-  assign dq = {
-    (dq_out_en & ~dqm_fifo[0][1]) ? dq_out[15:8] : {8{1'dz}},
-    (dq_out_en & ~dqm_fifo[0][0]) ? dq_out[7:0] : {8{1'dz}}
-  };
-
-  reg [2:0] bl;
-  reg [1:0] cl;
-  reg [12:0] row [4]; // 每个bank被激活的行
-
-  // 复位
-  always @(posedge clk) if (~cke) begin
-    dq_out_en <= 0;
-    for (integer i = 0; i < 3; i = i + 1) read_fifo_en[i] <= 0;
-    write_en_reg <= 0;
-  end
-
-  // -------------------- 指令执行 --------------------
-  wire nop = cs | (ras & cas & we);
-  always @(posedge clk) if (cke & ~nop) begin
-    case ({ras, cas, we})
-      3'b011: begin // ACTIVE
-        row[ba] <= a;
-      end
-      3'b101: begin // READ
-      end
-      3'b100: begin // WRITE
-      end
-      3'b110: begin // BURST TERMINATE
-        read_fifo_en[0] <= 0;
-        write_en_reg <= 0;
-      end
-      3'b000: begin // LOAD MODE REGISTER
-        bl <= a[2:0];
-        cl <= a[5:4] - 1;
-      end
-      default: begin end // NOP
-    endcase
-  end
-
-  // -------------------- READ --------------------
-  wire cmd_read = {cs, ras, cas, we} == 4'b0101;
-  // FIFO队列
-  reg read_fifo_en [3];
-  reg [1:0] read_fifo_bank [3];
-  reg [8:0] read_fifo_addr [3];
-  // 队头是0号
-  wire read_en = read_fifo_en[0];
-  wire [1:0] read_bank = read_fifo_bank[0];
-  wire [8:0] read_addr = read_fifo_addr[0];
-  wire [12:0] read_row = row[read_bank];
-  // 写入队头
-  wire       read_en_next   = cl == 2'b01 ? cmd_read : read_fifo_en[1];
-  wire [1:0] read_bank_next = cl == 2'b01 ? ba       : read_fifo_bank[1];
-  wire [8:0] read_addr_next = cl == 2'b01 ? a[8:0]   : read_fifo_addr[1];
-
-  // 插入元素
-  always @(posedge clk) if (cke) begin
-    if (read_en_next) begin
-      read_fifo_en[0] <= 1;
-      read_fifo_bank[0] <= read_bank_next;
-      read_fifo_addr[0] <= read_addr_next;
-    end
-    if (cl > 2'b01) begin
-      read_fifo_en[cl - 1] <= cmd_read;
-      read_fifo_bank[cl - 1] <= ba;
-      read_fifo_addr[cl - 1] <= a[8:0];
-    end
-    if (cl > 2'b10) begin
-      read_fifo_en[1] <= read_fifo_en[2];
-      read_fifo_bank[1] <= read_fifo_bank[2];
-      read_fifo_addr[1] <= read_fifo_addr[2];
-    end
-  end
-  // 根据队头读取数据
-  reg [2:0] read_cnt;
-  always @(posedge clk) if (cke) begin
-    if (read_en_next) begin
-      read_cnt <= 0;
-    end else begin
-      case (bl)
-        3'b000: read_fifo_addr[0] <= read_addr;
-        3'b001: read_fifo_addr[0] <= {read_addr[8:1], read_addr[0] + 1'b1};
-        3'b010: read_fifo_addr[0] <= {read_addr[8:2], read_addr[1:0] + 2'b01};
-        3'b011: read_fifo_addr[0] <= {read_addr[8:3], read_addr[2:0] + 3'b001};
-        3'b111: read_fifo_addr[0] <= read_addr + 1;
-        default: read_fifo_addr[0] <= read_addr;
-      endcase
-      read_cnt <= read_cnt + 1;
-      if ((bl != 3'b111) & (read_cnt == (1 << bl) - 1)) begin
-        read_fifo_en[0] <= 0;
-      end
-      if (cmd_write) read_fifo_en[0] <= 0;
-    end
-    if (read_en) begin
-      dq_out_en <= 1;
-      dq_out <= mem[read_bank][read_row][read_addr];
-    end else begin
-      dq_out_en <= 0;
-    end
-  end
-
-  // -------------------- WRITE --------------------
-  wire cmd_write = {cs, ras, cas, we} == 4'b0100;
-  reg write_en_reg;
-  reg [1:0] write_bank_reg;
-  reg [8:0] write_addr_reg;
-  wire write_en = cmd_write ? 1 : write_en_reg;
-  wire [1:0] write_bank = cmd_write ? ba : write_bank_reg;
-  wire [8:0] write_addr = cmd_write ? a[8:0] : write_addr_reg;
-  wire [12:0] write_row = row[write_bank];
-
-  reg [8:0] write_addr_next;
-  always_comb begin
-    case (bl)
-      3'b000: write_addr_next = write_addr;
-      3'b001: write_addr_next = {write_addr[8:1], write_addr[0] + 1'b1};
-      3'b010: write_addr_next = {write_addr[8:2], write_addr[1:0] + 2'b01};
-      3'b011: write_addr_next = {write_addr[8:3], write_addr[2:0] + 3'b001};
-      3'b111: write_addr_next = write_addr + 1;
-      default: write_addr_next = write_addr;
-    endcase
-  end
-
-  reg [2:0] write_cnt;
-  always @(posedge clk) if (cke) begin
-    if (cmd_write) begin
-      write_en_reg <= 1;
-      write_bank_reg <= ba;
-      write_addr_reg <= write_addr_next;
-      write_cnt <= 1;
-    end
-    if (write_en) begin
-      mem[write_bank][write_row][write_addr] <= {
-        dqm[1] ? mem[write_bank][write_row][write_addr][15:8] : dq[15:8],
-        dqm[0] ? mem[write_bank][write_row][write_addr][7:0] : dq[7:0]
-      };
-      if (~cmd_write) begin
-        write_cnt <= write_cnt + 1;
-        if ((bl != 3'b111) & (write_cnt == (1 << bl) - 1)) begin
-          write_en_reg <= 0;
-        end
-      end
-      if (cmd_read) write_en_reg <= 0;
-    end
-  end
+  sdram_comp comp_H (
+    .clk(clk), .cke(cke),
+    .cs(cs), .ras(ras), .cas(cas), .we(we),
+    .a(a), .ba(ba), .dqm(dqm[3:2]), .dq(dq[31:16])
+  );
+
+  sdram_comp comp_L (
+    .clk(clk), .cke(cke),
+    .cs(cs), .ras(ras), .cas(cas), .we(we),
+    .a(a), .ba(ba), .dqm(dqm[1:0]), .dq(dq[15:0])
+  );
 
 endmodule
diff --git a/perip/sdram/sdram_comp.v b/perip/sdram/sdram_comp.v
new file mode 100644
index 000000000..ad767496d
--- /dev/null
+++ b/perip/sdram/sdram_comp.v
@@ -0,0 +1,170 @@
+module sdram_comp(
+  input        clk,
+  input        cke,
+  input        cs,
+  input        ras,
+  input        cas,
+  input        we,
+  input [12:0] a,
+  input [ 1:0] ba,
+  input [ 1:0] dqm,
+  inout [15:0] dq
+);
+
+  reg [15:0] mem [4][8192][512];
+
+  // -------------------- I/O --------------------
+  reg [1:0] dqm_fifo [3];
+  always @(posedge clk) if (cke) begin
+    dqm_fifo[1] <= dqm;
+    dqm_fifo[0] <= dqm_fifo[1];
+  end
+  reg dq_out_en;
+  reg [15:0] dq_out;
+  assign dq = {
+    (dq_out_en & ~dqm_fifo[0][1]) ? dq_out[15:8] : {8{1'dz}},
+    (dq_out_en & ~dqm_fifo[0][0]) ? dq_out[7:0] : {8{1'dz}}
+  };
+
+  reg [2:0] bl;
+  reg [1:0] cl;
+  reg [12:0] row [4]; // 每个bank被激活的行
+
+  // 复位
+  always @(posedge clk) if (~cke) begin
+    dq_out_en <= 0;
+    for (integer i = 0; i < 3; i = i + 1) read_fifo_en[i] <= 0;
+    write_en_reg <= 0;
+  end
+
+  // -------------------- 指令执行 --------------------
+  wire nop = cs | (ras & cas & we);
+  always @(posedge clk) if (cke & ~nop) begin
+    case ({ras, cas, we})
+      3'b011: begin // ACTIVE
+        row[ba] <= a;
+      end
+      3'b101: begin // READ
+      end
+      3'b100: begin // WRITE
+      end
+      3'b110: begin // BURST TERMINATE
+        read_fifo_en[0] <= 0;
+        write_en_reg <= 0;
+      end
+      3'b000: begin // LOAD MODE REGISTER
+        bl <= a[2:0];
+        cl <= a[5:4] - 1;
+      end
+      default: begin end // NOP
+    endcase
+  end
+
+  // -------------------- READ --------------------
+  wire cmd_read = {cs, ras, cas, we} == 4'b0101;
+  // FIFO队列
+  reg read_fifo_en [3];
+  reg [1:0] read_fifo_bank [3];
+  reg [8:0] read_fifo_addr [3];
+  // 队头是0号
+  wire read_en = read_fifo_en[0];
+  wire [1:0] read_bank = read_fifo_bank[0];
+  wire [8:0] read_addr = read_fifo_addr[0];
+  wire [12:0] read_row = row[read_bank];
+  // 写入队头
+  wire       read_en_next   = cl == 2'b01 ? cmd_read : read_fifo_en[1];
+  wire [1:0] read_bank_next = cl == 2'b01 ? ba       : read_fifo_bank[1];
+  wire [8:0] read_addr_next = cl == 2'b01 ? a[8:0]   : read_fifo_addr[1];
+
+  // 插入元素
+  always @(posedge clk) if (cke) begin
+    if (read_en_next) begin
+      read_fifo_en[0] <= 1;
+      read_fifo_bank[0] <= read_bank_next;
+      read_fifo_addr[0] <= read_addr_next;
+    end
+    if (cl > 2'b01) begin
+      read_fifo_en[cl - 1] <= cmd_read;
+      read_fifo_bank[cl - 1] <= ba;
+      read_fifo_addr[cl - 1] <= a[8:0];
+    end
+    if (cl > 2'b10) begin
+      read_fifo_en[1] <= read_fifo_en[2];
+      read_fifo_bank[1] <= read_fifo_bank[2];
+      read_fifo_addr[1] <= read_fifo_addr[2];
+    end
+  end
+  // 根据队头读取数据
+  reg [2:0] read_cnt;
+  always @(posedge clk) if (cke) begin
+    if (read_en_next) begin
+      read_cnt <= 0;
+    end else begin
+      case (bl)
+        3'b000: read_fifo_addr[0] <= read_addr;
+        3'b001: read_fifo_addr[0] <= {read_addr[8:1], read_addr[0] + 1'b1};
+        3'b010: read_fifo_addr[0] <= {read_addr[8:2], read_addr[1:0] + 2'b01};
+        3'b011: read_fifo_addr[0] <= {read_addr[8:3], read_addr[2:0] + 3'b001};
+        3'b111: read_fifo_addr[0] <= read_addr + 1;
+        default: read_fifo_addr[0] <= read_addr;
+      endcase
+      read_cnt <= read_cnt + 1;
+      if ((bl != 3'b111) & (read_cnt == (1 << bl) - 1)) begin
+        read_fifo_en[0] <= 0;
+      end
+      if (cmd_write) read_fifo_en[0] <= 0;
+    end
+    if (read_en) begin
+      dq_out_en <= 1;
+      dq_out <= mem[read_bank][read_row][read_addr];
+    end else begin
+      dq_out_en <= 0;
+    end
+  end
+
+  // -------------------- WRITE --------------------
+  wire cmd_write = {cs, ras, cas, we} == 4'b0100;
+  reg write_en_reg;
+  reg [1:0] write_bank_reg;
+  reg [8:0] write_addr_reg;
+  wire write_en = cmd_write ? 1 : write_en_reg;
+  wire [1:0] write_bank = cmd_write ? ba : write_bank_reg;
+  wire [8:0] write_addr = cmd_write ? a[8:0] : write_addr_reg;
+  wire [12:0] write_row = row[write_bank];
+
+  reg [8:0] write_addr_next;
+  always_comb begin
+    case (bl)
+      3'b000: write_addr_next = write_addr;
+      3'b001: write_addr_next = {write_addr[8:1], write_addr[0] + 1'b1};
+      3'b010: write_addr_next = {write_addr[8:2], write_addr[1:0] + 2'b01};
+      3'b011: write_addr_next = {write_addr[8:3], write_addr[2:0] + 3'b001};
+      3'b111: write_addr_next = write_addr + 1;
+      default: write_addr_next = write_addr;
+    endcase
+  end
+
+  reg [2:0] write_cnt;
+  always @(posedge clk) if (cke) begin
+    if (cmd_write) begin
+      write_en_reg <= bl != 3'b0;
+      write_bank_reg <= ba;
+      write_addr_reg <= write_addr_next;
+      write_cnt <= 1;
+    end
+    if (write_en) begin
+      mem[write_bank][write_row][write_addr] <= {
+        dqm[1] ? mem[write_bank][write_row][write_addr][15:8] : dq[15:8],
+        dqm[0] ? mem[write_bank][write_row][write_addr][7:0] : dq[7:0]
+      };
+      if (~cmd_write) begin
+        write_cnt <= write_cnt + 1;
+        if ((bl != 3'b111) & (write_cnt == (1 << bl) - 1)) begin
+          write_en_reg <= 0;
+        end
+      end
+      if (cmd_read) write_en_reg <= 0;
+    end
+  end
+
+endmodule
diff --git a/perip/sdram/sdram_top_apb.v b/perip/sdram/sdram_top_apb.v
index 3bc5b93b7..f127d7143 100644
--- a/perip/sdram/sdram_top_apb.v
+++ b/perip/sdram/sdram_top_apb.v
@@ -20,13 +20,13 @@ module sdram_top_apb (
   output        sdram_we,
   output [12:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [31:0] sdram_dq
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  assign sdram_dq = sdram_dout_en ? sdram_dout : 32'bz;
 
   typedef enum [1:0] { ST_IDLE, ST_WAIT_ACCEPT, ST_WAIT_ACK } state_t;
   reg [1:0] state;
diff --git a/perip/sdram/sdram_top_axi.v b/perip/sdram/sdram_top_axi.v
index f0fd6fdbf..5731f0def 100644
--- a/perip/sdram/sdram_top_axi.v
+++ b/perip/sdram/sdram_top_axi.v
@@ -39,13 +39,13 @@ module sdram_top_axi(
   output        sdram_we,
   output [12:0] sdram_a,
   output [ 1:0] sdram_ba,
-  output [ 1:0] sdram_dqm,
-  inout  [15:0] sdram_dq
+  output [ 3:0] sdram_dqm,
+  inout  [31:0] sdram_dq
 );
 
   wire sdram_dout_en;
-  wire [15:0] sdram_dout;
-  assign sdram_dq = sdram_dout_en ? sdram_dout : 16'bz;
+  wire [31:0] sdram_dout;
+  assign sdram_dq = sdram_dout_en ? sdram_dout : 32'bz;
   sdram_axi #(
     .SDRAM_MHZ(100),
     .SDRAM_ADDR_W(24),
diff --git a/src/device/SDRAM.scala b/src/device/SDRAM.scala
index 403647dec..ee948ef57 100644
--- a/src/device/SDRAM.scala
+++ b/src/device/SDRAM.scala
@@ -19,8 +19,8 @@ class SDRAMIO extends Bundle {
   val we  = Output(Bool())
   val a   = Output(UInt(13.W))
   val ba  = Output(UInt(2.W))
-  val dqm = Output(UInt(2.W))
-  val dq  = Analog(16.W)
+  val dqm = Output(UInt(4.W))
+  val dq  = Analog(32.W)
 }
 
 class sdram_top_axi extends BlackBox {
-- 
2.50.1

