From 61df0ac5c19d5dd8799a63eb24aef81f05e75aef Mon Sep 17 00:00:00 2001
From: CmdBlock <CmdBlockZQG@outlook.com>
Date: Mon, 22 Apr 2024 03:22:49 +0800
Subject: [PATCH 01/13] migrate from old version

---
 perip/bitrev/bitrev.v                |  29 ++++-
 perip/psram/efabless/EF_PSRAM_CTRL.v |  58 +++++-----
 perip/psram/psram.v                  |  95 +++++++++++++++-
 perip/psram/psram_top_apb.v          |  47 ++++++--
 perip/sdram/sdram.v                  | 156 ++++++++++++++++++++++++++-
 perip/spi/rtl/spi_top_apb.v          | 155 ++++++++++++++++++++++++--
 src/CPU.scala                        |   4 +-
 7 files changed, 493 insertions(+), 51 deletions(-)

diff --git a/perip/bitrev/bitrev.v b/perip/bitrev/bitrev.v
index f1c3b3637..bc602fd45 100644
--- a/perip/bitrev/bitrev.v
+++ b/perip/bitrev/bitrev.v
@@ -4,5 +4,32 @@ module bitrev (
   input  mosi,
   output miso
 );
-  assign miso = 1'b1;
+  reg [7:0] bits;
+  reg [2:0] cnt_in;
+  reg state; // 0:receive 1:send
+  always @(negedge sck or posedge ss) begin
+    if (ss) begin
+      cnt_in <= 0;
+      state <= 0;
+    end else if (~state) begin
+      bits <= {bits[6:0], mosi};
+      cnt_in <= cnt_in + 1;
+      if (cnt_in == 3'd7) begin
+        state <= 1;
+      end
+    end
+  end
+
+  reg [2:0] cnt_out;
+  reg out;
+  assign miso = ss | ~state | out;
+  always @(posedge sck or posedge ss) begin
+    if (ss) begin
+      cnt_out <= 0;
+      out <= 1;
+    end else if (state) begin
+      out <= bits[cnt_out];
+      cnt_out <= cnt_out + 1;
+    end
+  end
 endmodule
diff --git a/perip/psram/efabless/EF_PSRAM_CTRL.v b/perip/psram/efabless/EF_PSRAM_CTRL.v
index b6e737e9c..9ef9dc183 100644
--- a/perip/psram/efabless/EF_PSRAM_CTRL.v
+++ b/perip/psram/efabless/EF_PSRAM_CTRL.v
@@ -60,7 +60,7 @@ module PSRAM_READER (
     localparam  IDLE = 1'b0,
                 READ = 1'b1;
 
-    wire [7:0]  FINAL_COUNT = 19 + size*2; // was 27: Always read 1 word
+    wire [7:0]  FINAL_COUNT = 14 + size*2; // was 22: Always read 1 word
 
     reg         state, nstate;
     reg [7:0]   counter;
@@ -112,23 +112,24 @@ module PSRAM_READER (
             //saddr <= {addr[23:2], 2'b0};
             saddr <= {addr[23:0]};
 
-    // Sample with the negedge of sck
-    wire[1:0] byte_index = {counter[7:1] - 8'd10}[1:0];
+    // Sample with the posedge of sck
+    wire[1:0] byte_index = {counter[7:0] - 8'd111}[2:1];
     always @ (posedge clk)
-        if(counter >= 20 && counter <= FINAL_COUNT)
-            if(sck)
+        if(counter >= 15 && counter <= FINAL_COUNT)
+            if(~sck)
                 data[byte_index] <= {data[byte_index][3:0], din}; // Optimize!
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_EBH[7 - counter]}:
-                        (counter == 8)  ?   saddr[23:20]        :
-                        (counter == 9)  ?   saddr[19:16]        :
-                        (counter == 10) ?   saddr[15:12]        :
-                        (counter == 11) ?   saddr[11:8]         :
-                        (counter == 12) ?   saddr[7:4]          :
-                        (counter == 13) ?   saddr[3:0]          :
+    assign dout     =   (counter == 0)  ?   CMD_EBH[7:4]        :
+                        (counter == 1)  ?   CMD_EBH[3:0]        :
+                        (counter == 2)  ?   saddr[23:20]        :
+                        (counter == 3)  ?   saddr[19:16]        :
+                        (counter == 4)  ?   saddr[15:12]        :
+                        (counter == 5)  ?   saddr[11:8]         :
+                        (counter == 6)  ?   saddr[7:4]          :
+                        (counter == 7)  ?   saddr[3:0]          :
                         4'h0;
 
-    assign douten   = (counter < 14);
+    assign douten   = (counter < 8);
 
     assign done     = (counter == FINAL_COUNT+1);
 
@@ -161,7 +162,7 @@ module PSRAM_WRITER (
     localparam  IDLE = 1'b0,
                 WRITE = 1'b1;
 
-    wire[7:0]        FINAL_COUNT = 13 + size*2;
+    wire[7:0]        FINAL_COUNT = 7 + size*2;
 
     reg         state, nstate;
     reg [7:0]   counter;
@@ -212,20 +213,21 @@ module PSRAM_WRITER (
         else if((state == IDLE) && wr)
             saddr <= addr;
 
-    assign dout     =   (counter < 8)   ?   {3'b0, CMD_38H[7 - counter]}:
-                        (counter == 8)  ?   saddr[23:20]        :
-                        (counter == 9)  ?   saddr[19:16]        :
-                        (counter == 10) ?   saddr[15:12]        :
-                        (counter == 11) ?   saddr[11:8]         :
-                        (counter == 12) ?   saddr[7:4]          :
-                        (counter == 13) ?   saddr[3:0]          :
-                        (counter == 14) ?   line[7:4]           :
-                        (counter == 15) ?   line[3:0]           :
-                        (counter == 16) ?   line[15:12]         :
-                        (counter == 17) ?   line[11:8]          :
-                        (counter == 18) ?   line[23:20]         :
-                        (counter == 19) ?   line[19:16]         :
-                        (counter == 20) ?   line[31:28]         :
+    assign dout     =   (counter == 0)  ?   CMD_38H[7:4]        :
+                        (counter == 1)  ?   CMD_38H[3:0]        :
+                        (counter == 2)  ?   saddr[23:20]        :
+                        (counter == 3)  ?   saddr[19:16]        :
+                        (counter == 4)  ?   saddr[15:12]        :
+                        (counter == 5)  ?   saddr[11:8]         :
+                        (counter == 6)  ?   saddr[7:4]          :
+                        (counter == 7)  ?   saddr[3:0]          :
+                        (counter == 8)  ?   line[7:4]           :
+                        (counter == 9)  ?   line[3:0]           :
+                        (counter == 10) ?   line[15:12]         :
+                        (counter == 11) ?   line[11:8]          :
+                        (counter == 12) ?   line[23:20]         :
+                        (counter == 13) ?   line[19:16]         :
+                        (counter == 14) ?   line[31:28]         :
                         line[27:24];
 
     assign douten   = (~ce_n);
diff --git a/perip/psram/psram.v b/perip/psram/psram.v
index d9bdd8820..c68b5e415 100644
--- a/perip/psram/psram.v
+++ b/perip/psram/psram.v
@@ -4,6 +4,99 @@ module psram(
   inout [3:0] dio
 );
 
-  assign dio = 4'bz;
+  typedef enum { st_inst, st_addr, st_wait, st_data_out, st_data_in } st_t;
+  st_t st;
+
+  reg qpi;
+  reg [3:0] spi_out, qpi_out;
+  wire out_en = st == st_data_out;
+  assign dio = out_en ? (qpi ? qpi_out : spi_out) : 4'bzzzz;
+
+  reg [7:0] inst;
+  reg [21:0] addr;
+  reg [2:0] cnt;
+
+  reg [7:0] mem [4194304];
+
+  initial begin
+    st = st_inst;
+    cnt = 0;
+    qpi = 0;
+  end
+
+  always @(posedge sck or posedge ce_n) if (ce_n) begin // 复位
+    st <= st_inst;
+    cnt <= 0;
+  end
+
+  always @(posedge sck or posedge ce_n) if (~ce_n) begin
+    case (st)
+      st_inst: begin
+        if (qpi) begin
+          inst <= {inst[3:0], dio};
+          if (cnt[0]) begin
+            cnt <= 0;
+            st <= st_addr;
+          end else begin
+            cnt[0] <= 1;
+          end
+        end else begin
+          cnt <= cnt + 1;
+          inst <= {inst[6:0], dio[0]};
+          if (cnt == 3'b111) begin
+            st <= st_addr;
+            if ({inst[6:0], dio[0]} == 8'h35) begin //  QPI Mode Enable
+              qpi <= 1;
+            end
+          end
+        end
+      end
+      st_addr: begin
+        addr <= {addr[17:0], dio[3:0]};
+        if (cnt == 3'd5) begin
+          case (inst)
+            8'heb: st <= st_wait;
+            8'h38: st <= st_data_in;
+            default: begin end
+          endcase
+          cnt <= 0;
+        end else begin
+          cnt <= cnt + 1;
+        end
+      end
+      st_wait: begin
+        if (cnt == 3'd5) begin
+          st <= st_data_out;
+          cnt <= 0;
+        end else begin
+          cnt <= cnt + 1;
+        end
+      end
+      st_data_out: begin
+        cnt <= cnt + 1;
+        if (cnt[0]) begin
+          spi_out <= mem[addr][3:0];
+          addr <= addr + 1;
+        end else begin
+          spi_out <= mem[addr][7:4];
+        end
+      end
+      st_data_in: begin
+        cnt <= cnt + 1;
+        if (cnt[0]) begin
+          mem[addr] <= {inst[3:0], dio};
+          addr <= addr + 1;
+        end else begin
+          inst[3:0] <= dio;
+        end
+      end
+      default: begin
+      end
+    endcase
+  end
+
+  always @(negedge sck) begin
+    qpi_out <= spi_out;
+  end
 
 endmodule
diff --git a/perip/psram/psram_top_apb.v b/perip/psram/psram_top_apb.v
index 0ba9c2f2e..159693240 100644
--- a/perip/psram/psram_top_apb.v
+++ b/perip/psram/psram_top_apb.v
@@ -17,8 +17,36 @@ module psram_top_apb (
   inout  [3:0] qspi_dio
 );
 
+  parameter reg [7:0] QPI_ENABLE = 8'h35;
+  reg qpi, init_sck, init_ce_n;
+  reg [2:0] init_cnt;
+  wire init_out = QPI_ENABLE[init_cnt];
+
+  always @(posedge clock) if (reset) begin
+    qpi <= 0;
+    init_sck <= 0;
+    init_ce_n <= 1;
+    init_cnt <= 3'b111;
+  end
+
+  always @(posedge clock) if (~qpi) begin
+    if (init_ce_n) begin
+      init_ce_n <= 0;
+    end else begin
+      init_sck <= ~init_sck;
+      if (init_sck) begin
+        init_cnt <= init_cnt - 1;
+        if (init_cnt == 0) begin
+          init_ce_n <= 1;
+          qpi <= 1;
+        end
+      end
+    end
+  end
+
   wire [3:0] din, dout, douten;
   wire ack;
+  wire sck, ce_n;
   EF_PSRAM_CTRL_wb u0 (
     .clk_i(clock),
     .rst_i(reset),
@@ -26,21 +54,24 @@ module psram_top_apb (
     .dat_i(in_pwdata),
     .dat_o(in_prdata),
     .sel_i(in_pstrb),
-    .cyc_i(in_psel),
-    .stb_i(in_psel),
+    .cyc_i(qpi & in_psel),
+    .stb_i(qpi & in_psel),
     .ack_o(ack),
     .we_i(in_pwrite),
-  
-    .sck(qspi_sck),
-    .ce_n(qspi_ce_n),
+
+    .sck(sck),
+    .ce_n(ce_n),
     .din(din),
     .dout(dout),
     .douten(douten)
   );
-  
-  assign in_pready = ack && in_psel;
+
+  assign qspi_sck = qpi ? sck : init_sck;
+  assign qspi_ce_n = qpi ? ce_n : init_ce_n;
+
+  assign in_pready = qpi && ack && in_psel;
   assign in_pslverr = 1'b0;
-  assign qspi_dio[0] = douten[0] ? dout[0] : 1'bz;
+  assign qspi_dio[0] = qpi ? (douten[0] ? dout[0] : 1'bz) : init_out;
   assign qspi_dio[1] = douten[1] ? dout[1] : 1'bz;
   assign qspi_dio[2] = douten[2] ? dout[2] : 1'bz;
   assign qspi_dio[3] = douten[3] ? dout[3] : 1'bz;
diff --git a/perip/sdram/sdram.v b/perip/sdram/sdram.v
index 3613b2316..75cb87ad4 100644
--- a/perip/sdram/sdram.v
+++ b/perip/sdram/sdram.v
@@ -11,6 +11,160 @@ module sdram(
   inout [15:0] dq
 );
 
-  assign dq = 16'bz;
+  reg [15:0] mem [4][8192][512];
+
+  // -------------------- I/O --------------------
+  reg [1:0] dqm_fifo [3];
+  always @(posedge clk) if (cke) begin
+    dqm_fifo[1] <= dqm;
+    dqm_fifo[0] <= dqm_fifo[1];
+  end
+  reg dq_out_en;
+  reg [15:0] dq_out;
+  assign dq = {
+    (dq_out_en & ~dqm_fifo[0][1]) ? dq_out[15:8] : {8{1'dz}},
+    (dq_out_en & ~dqm_fifo[0][0]) ? dq_out[7:0] : {8{1'dz}}
+  };
+
+  reg [2:0] bl;
+  reg [1:0] cl;
+  reg [12:0] row [4]; // 每个bank被激活的行
+
+  // 复位
+  always @(posedge clk) if (~cke) begin
+    dq_out_en <= 0;
+    for (integer i = 0; i < 3; i = i + 1) read_fifo_en[i] <= 0;
+    write_en_reg <= 0;
+  end
+
+  // -------------------- 指令执行 --------------------
+  wire nop = cs | (ras & cas & we);
+  always @(posedge clk) if (cke & ~nop) begin
+    case ({ras, cas, we})
+      3'b011: begin // ACTIVE
+        row[ba] <= a;
+      end
+      3'b101: begin // READ
+      end
+      3'b100: begin // WRITE
+      end
+      3'b110: begin // BURST TERMINATE
+        read_fifo_en[0] <= 0;
+        write_en_reg <= 0;
+      end
+      3'b000: begin // LOAD MODE REGISTER
+        bl <= a[2:0];
+        cl <= a[5:4] - 1;
+      end
+      default: begin end // NOP
+    endcase
+  end
+
+  // -------------------- READ --------------------
+  wire cmd_read = {cs, ras, cas, we} == 4'b0101;
+  // FIFO队列
+  reg read_fifo_en [3];
+  reg [1:0] read_fifo_bank [3];
+  reg [8:0] read_fifo_addr [3];
+  // 队头是0号
+  wire read_en = read_fifo_en[0];
+  wire [1:0] read_bank = read_fifo_bank[0];
+  wire [8:0] read_addr = read_fifo_addr[0];
+  wire [12:0] read_row = row[read_bank];
+  // 写入队头
+  wire       read_en_next   = cl == 2'b01 ? cmd_read : read_fifo_en[1];
+  wire [1:0] read_bank_next = cl == 2'b01 ? ba       : read_fifo_bank[1];
+  wire [8:0] read_addr_next = cl == 2'b01 ? a[8:0]   : read_fifo_addr[1];
+
+  // 插入元素
+  always @(posedge clk) if (cke) begin
+    if (read_en_next) begin
+      read_fifo_en[0] <= 1;
+      read_fifo_bank[0] <= read_bank_next;
+      read_fifo_addr[0] <= read_addr_next;
+    end
+    if (cl > 2'b01) begin
+      read_fifo_en[cl - 1] <= cmd_read;
+      read_fifo_bank[cl - 1] <= ba;
+      read_fifo_addr[cl - 1] <= a[8:0];
+    end
+    if (cl > 2'b10) begin
+      read_fifo_en[1] <= read_fifo_en[2];
+      read_fifo_bank[1] <= read_fifo_bank[2];
+      read_fifo_addr[1] <= read_fifo_addr[2];
+    end
+  end
+  // 根据队头读取数据
+  reg [2:0] read_cnt;
+  always @(posedge clk) if (cke) begin
+    if (read_en_next) begin
+      read_cnt <= 0;
+    end else begin
+      case (bl)
+        3'b000: read_fifo_addr[0] <= read_addr;
+        3'b001: read_fifo_addr[0] <= {read_addr[8:1], read_addr[0] + 1'b1};
+        3'b010: read_fifo_addr[0] <= {read_addr[8:2], read_addr[1:0] + 2'b01};
+        3'b011: read_fifo_addr[0] <= {read_addr[8:3], read_addr[2:0] + 3'b001};
+        3'b111: read_fifo_addr[0] <= read_addr + 1;
+        default: read_fifo_addr[0] <= read_addr;
+      endcase
+      read_cnt <= read_cnt + 1;
+      if ((bl != 3'b111) & (read_cnt == (1 << bl) - 1)) begin
+        read_fifo_en[0] <= 0;
+      end
+      if (cmd_write) read_fifo_en[0] <= 0;
+    end
+    if (read_en) begin
+      dq_out_en <= 1;
+      dq_out <= mem[read_bank][read_row][read_addr];
+    end else begin
+      dq_out_en <= 0;
+    end
+  end
+
+  // -------------------- WRITE --------------------
+  wire cmd_write = {cs, ras, cas, we} == 4'b0100;
+  reg write_en_reg;
+  reg [1:0] write_bank_reg;
+  reg [8:0] write_addr_reg;
+  wire write_en = cmd_write ? 1 : write_en_reg;
+  wire [1:0] write_bank = cmd_write ? ba : write_bank_reg;
+  wire [8:0] write_addr = cmd_write ? a[8:0] : write_addr_reg;
+  wire [12:0] write_row = row[write_bank];
+
+  reg [8:0] write_addr_next;
+  always_comb begin
+    case (bl)
+      3'b000: write_addr_next = write_addr;
+      3'b001: write_addr_next = {write_addr[8:1], write_addr[0] + 1'b1};
+      3'b010: write_addr_next = {write_addr[8:2], write_addr[1:0] + 2'b01};
+      3'b011: write_addr_next = {write_addr[8:3], write_addr[2:0] + 3'b001};
+      3'b111: write_addr_next = write_addr + 1;
+      default: write_addr_next = write_addr;
+    endcase
+  end
+
+  reg [2:0] write_cnt;
+  always @(posedge clk) if (cke) begin
+    if (cmd_write) begin
+      write_en_reg <= 1;
+      write_bank_reg <= ba;
+      write_addr_reg <= write_addr_next;
+      write_cnt <= 1;
+    end
+    if (write_en) begin
+      mem[write_bank][write_row][write_addr] <= {
+        dqm[1] ? mem[write_bank][write_row][write_addr][15:8] : dq[15:8],
+        dqm[0] ? mem[write_bank][write_row][write_addr][7:0] : dq[7:0]
+      };
+      if (~cmd_write) begin
+        write_cnt <= write_cnt + 1;
+        if ((bl != 3'b111) & (write_cnt == (1 << bl) - 1)) begin
+          write_en_reg <= 0;
+        end
+      end
+      if (cmd_read) write_en_reg <= 0;
+    end
+  end
 
 endmodule
diff --git a/perip/spi/rtl/spi_top_apb.v b/perip/spi/rtl/spi_top_apb.v
index 92d37516c..335b1a542 100644
--- a/perip/spi/rtl/spi_top_apb.v
+++ b/perip/spi/rtl/spi_top_apb.v
@@ -1,6 +1,6 @@
 // define this macro to enable fast behavior simulation
 // for flash by skipping SPI transfers
-//`define FAST_FLASH
+`define FAST_FLASH
 
 module spi_top_apb #(
   parameter flash_addr_start = 32'h30000000,
@@ -48,18 +48,20 @@ assign in_prdata  = data[31:0];
 
 `else
 
+wire flash_xip = in_psel & (flash_addr_start <= in_paddr && in_paddr <= flash_addr_end);
+
 spi_top u0_spi_top (
   .wb_clk_i(clock),
   .wb_rst_i(reset),
-  .wb_adr_i(in_paddr[4:0]),
-  .wb_dat_i(in_pwdata),
-  .wb_dat_o(in_prdata),
-  .wb_sel_i(in_pstrb),
-  .wb_we_i (in_pwrite),
-  .wb_stb_i(in_psel),
-  .wb_cyc_i(in_penable),
-  .wb_ack_o(in_pready),
-  .wb_err_o(in_pslverr),
+  .wb_adr_i(flash_xip ? addr : in_paddr[4:0]),
+  .wb_dat_i(flash_xip ? wdata : in_pwdata),
+  .wb_dat_o(wb_dat_o),
+  .wb_sel_i(flash_xip ? 4'b1111 : in_pstrb),
+  .wb_we_i (flash_xip ? mode : in_pwrite),
+  .wb_stb_i(flash_xip ? valid : in_penable), // wb_stb:选通/valid
+  .wb_cyc_i(flash_xip ? 1 : in_psel), // wb_cyc:占有
+  .wb_ack_o(wb_ack_o),
+  .wb_err_o(wb_err_o),
   .wb_int_o(spi_irq_out),
 
   .ss_pad_o(spi_ss),
@@ -68,6 +70,139 @@ spi_top u0_spi_top (
   .miso_pad_i(spi_miso)
 );
 
+wire [31:0] wb_dat_o;
+wire wb_ack_o, wb_err_o;
+assign in_pready = flash_xip ? ready : wb_ack_o;
+assign in_pslverr = flash_xip ? err : wb_err_o;
+assign in_prdata = flash_xip ? rdata: wb_dat_o;
+
+reg [4:0] addr;
+reg [31:0] wdata, rdata;
+reg mode; // 1:write 0:read
+reg valid; // 发送到wb_slave
+reg ready, err; // 发送到apb_master
+
+typedef enum { apb_idle, apb_setup, apb_access } apb_state_t;
+apb_state_t st_apb;
+typedef enum {
+  xip_none,
+  xip_ctrl, xip_div, xip_ss, xip_inst,
+  xip_go, xip_wait, xip_resp
+} xip_state_t;
+xip_state_t st_xip;
+
+always @(posedge clock) begin
+  if (reset) begin // 复位
+    mode <= 0;
+    valid <= 0;
+    ready <= 1;
+    err <= 0;
+    st_apb <= apb_idle;
+    st_xip <= xip_none;
+  end
+end
+
+always @(posedge clock) begin if (~reset & flash_xip) begin
+  if (st_apb == apb_idle) begin
+    if (in_psel) begin
+      if (in_pwrite) begin // 不支持写操作！
+        $fwrite(32'h80000002, "Assertion failed: XIP mode does not sopport write operation!\n");
+        $fatal;
+      end
+      st_apb <= apb_setup;
+      ready <= 0;
+    end
+  end
+  if (st_apb == apb_setup) begin
+    st_apb <= apb_access;
+    st_xip <= xip_ctrl;
+  end
+  if (st_apb == apb_access) begin
+    if (ready) begin
+      st_apb <= apb_idle;
+    end
+    // 设置控制寄存器
+    if (st_xip == xip_ctrl) begin
+      if (~valid) begin
+        mode <= 1;
+        addr <= 5'b10000;
+        wdata <= {18'b0, 14'b11010001000000};
+        valid <= 1;
+      end else if (wb_ack_o) begin
+        valid <= 0;
+        st_xip <= xip_div;
+      end
+    end
+    // 设置除数
+    if (st_xip == xip_ctrl) begin
+      if (~valid) begin
+        mode <= 1;
+        addr <= 5'b10100;
+        wdata <= 0;
+        valid <= 1;
+      end else if (wb_ack_o) begin
+        valid <= 0;
+        st_xip <= xip_ss;
+      end
+    end
+    // 设置slave设备
+    if (st_xip == xip_ss) begin
+      if (~valid) begin
+        mode <= 1;
+        addr <= 5'b11000;
+        wdata <= 1;
+        valid <= 1;
+      end else if (wb_ack_o) begin
+        valid <= 0;
+        st_xip <= xip_inst;
+      end
+    end
+    // 设置指令
+    if (st_xip == xip_inst) begin
+      if (~valid) begin
+        mode <= 1;
+        addr <= 5'b00100;
+        wdata <= {8'h03, in_paddr[23:2], 2'b0};
+        valid <= 1;
+      end else if (wb_ack_o) begin
+        valid <= 0;
+        st_xip <= xip_go;
+      end
+    end
+    // 设置go_bsy
+    if (st_xip == xip_go) begin
+      if (~valid) begin
+        mode <= 1;
+        addr <= 5'b10000;
+        wdata <= {18'b0, 14'b11010101000000};
+        valid <= 1;
+      end else if (wb_ack_o) begin
+        valid <= 0;
+        st_xip <= xip_wait;
+      end
+    end
+    // 等待结果中断信号
+    if (st_xip == xip_wait) begin
+      if (spi_irq_out) st_xip <= xip_resp;
+    end
+    // 返回结果
+    if (st_xip == xip_resp) begin
+      if (~valid) begin
+        mode <= 0;
+        addr <= 0;
+        valid <= 1;
+      end else if (wb_ack_o) begin
+        valid <= 0;
+        rdata <= {wb_dat_o[7:0], wb_dat_o[15:8],
+                  wb_dat_o[23:16], wb_dat_o[31:24]};
+        ready <= 1;
+        st_xip <= xip_none;
+      end
+    end
+  end
+end end
+
+
 `endif // FAST_FLASH
 
 endmodule
diff --git a/src/CPU.scala b/src/CPU.scala
index 6c0498f80..86afef165 100644
--- a/src/CPU.scala
+++ b/src/CPU.scala
@@ -13,7 +13,7 @@ object CPUAXI4BundleParameters {
   def apply() = AXI4BundleParameters(addrBits = 32, dataBits = 64, idBits = ChipLinkParam.idBits)
 }
 
-class ysyx_00000000 extends BlackBox {
+class ysyx_23060203 extends BlackBox {
   val io = IO(new Bundle {
     val clock = Input(Clock())
     val reset = Input(Reset())
@@ -35,7 +35,7 @@ class CPU(idBits: Int)(implicit p: Parameters) extends LazyModule {
     val interrupt = IO(Input(Bool()))
     val slave = IO(Flipped(AXI4Bundle(CPUAXI4BundleParameters())))
 
-    val cpu = Module(new ysyx_00000000)
+    val cpu = Module(new ysyx_23060203)
     cpu.io.clock := clock
     cpu.io.reset := reset
     cpu.io.io_interrupt := interrupt
-- 
2.50.1

